<!DOCTYPE html>
<html>
<head>
    <title>Graph Visualization with vis.js</title>
    <style type="text/css">
        #graph-container {
            width: 800px;
            height: 600px;
            border: 1px solid lightgray;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis-network.min.js"></script>
	<script src="script.js"></script>
</head>
<body>
    <div id="graph-container"></div>
    <button id="reset-button">RESET</button>
	<button id="dfs-button">Run DFS</button>
	<button id="bfs-button">Run BFS</button>
	<button id="dijkstra-button">Run DIJKSTRA</button>

    <script type="text/javascript">
        const adjVertices = {
    		A: { B: 1, C: 4 },
    		B: { A: 1, C: 2, D: 5 },
    		C: { A: 4, B: 2, D: 1 },
    		D: { B: 5, C: 1 },
		};

        
        const nodes = new vis.DataSet();
        const edges = new vis.DataSet();

        const container = document.getElementById('graph-container');
        container.style.width = '800px';
        container.style.height = '500px';

        const data = {
            nodes: nodes,
            edges: edges
        };

        const options = {
            nodes: {
                color: 'blue',
            },
            edges: {
                color: {
                    color: 'black',
                    inherit: false
                }
            },
        };

        const network = new vis.Network(container, data, options);

        function populateGraph(adjVertices) {
			const addedEdges = new Set(); // To track added edges

    		for (const node in adjVertices) {
        		nodes.add({ id: node, label: node , color:'blue'});

        		for (const neighbor in adjVertices[node]) {
					const edgeId = `${node}-${neighbor}`;
					const reverseEdgeId = `${neighbor}-${node}`;
            		const weight = adjVertices[node][neighbor];

            		// Check if the edge is already added
           			if (!addedEdges.has(edgeId) && !addedEdges.has(reverseEdgeId)) {
                		edges.add({ id: edgeId, from: node, to: neighbor, label: String(weight), color:'black' });
						addedEdges.add(edgeId)
            		}
        		}
    		}
		}

        populateGraph(adjVertices); // Populate the graph with your desired data
		
		const dfsButton = document.getElementById('dfs-button');
        dfsButton.addEventListener('click', () => {
            const startNode = prompt('Enter the starting node for DFS:');
            if (startNode) {
                runDFS(startNode);
            }
        });
		const bfsButton = document.getElementById('bfs-button');
        bfsButton.addEventListener('click', () => {
            const startNode = prompt('Enter the starting node for BFS:');
            if (startNode) {
                runBFS(startNode);
            }
        });
		const dijkstraButton = document.getElementById('dijkstra-button');
        dijkstraButton.addEventListener('click', () => {
            const startNode = prompt('Enter the starting node for dijkstra:');
            const endNode = prompt('Enter the ending node for dijkstra:')
            if (startNode && endNode) {
                runDijkstra(startNode,endNode);
            }
        });
        const resetButton = document.getElementById('reset-button');
        resetButton.addEventListener('click', () => {
            timers.forEach(timeoutId => clearTimeout(timeoutId));
            edges.clear();
            nodes.clear();
            populateGraph(adjVertices);
        });
        const timers = [];
        async function colorNodes(nodeList){
            const delay = ms => new Promise(resolve => {
                const timeoutId = setTimeout(resolve, ms);
                timers.push(timeoutId);
            });

            for(const node of nodeList) {
                network.body.data.nodes.update([{id: node, color: 'yellow'}]);
                await delay(1000);
            }
        }
        function runDFS(startNode){
            const result = [];

            function DFSUtil(node, result) {
                if (!result.includes(node)) {
                    result.push(node);
                    const neighbors = Object.keys(adjVertices[node]);
                    for (const n of neighbors) {
                        DFSUtil(n, result);
                    }
                }
            }

            DFSUtil(startNode, result);
            colorNodes(result)
        }

		function runBFS(startNode) {
            const result = [];
			const queue = [];

            queue.push(startNode);

            while (queue.length > 0) {
                const current = queue.shift();

                if (!result.includes(current)) {
                    result.push(current);
                    queue.push(...Object.keys(adjVertices[current]));
                }
            }
            colorNodes(result);
		}

        function runDijkstra(start,finish){
            const visitedNodes = new Set();
            const distance = new Map();
            const previousNode = new Map();

            function getNodeWithShortestDistance() {
                let result = null;
                let shortestDistance = Infinity;
                for (const node of distance.keys()) {
                    if (!visitedNodes.has(node) && distance.get(node) < shortestDistance) {
                        result = node;
                        shortestDistance = distance.get(node);
                    }
                }
                return result;
            }

            function getShortestPath(endNode) {
                const path = [];
                let currentNode = endNode;
                while (currentNode !== null) {
                    path.unshift(currentNode);
                    currentNode = previousNode.get(currentNode);
                }
                return path;
            }

            for (const node of Object.keys(adjVertices)) {
                if (node === start) {
                    distance.set(node, 0);
                } else {
                    distance.set(node, Infinity);
                }
                previousNode.set(node, null);
            }

            while (!visitedNodes.has(finish)) {
                const currentNode = getNodeWithShortestDistance();
                visitedNodes.add(currentNode);

                const neighbors = adjVertices[currentNode];
                for (const neighbor in neighbors) {
                    const cost = neighbors[neighbor];
                    const totalCost = cost + distance.get(currentNode);
                    if (totalCost < distance.get(neighbor)) {
                        distance.set(neighbor, totalCost);
                        previousNode.set(neighbor, currentNode);
                    }
                }
            }

            async function colorNodesSequentially() {
                const path = getShortestPath(finish);
                const delay = ms => new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    timers.push(timeoutId);
                });

                let previousNode = path.shift();
                network.body.data.nodes.update([{ id: previousNode, color: 'yellow' }]);
                await delay(1000);

                for (const node of path) {
                    const edgeId =`${node}-${previousNode}`
                    const reverseId =`${previousNode}-${node}`
                    if(edges.get(edgeId)){
                        edges.update({id:edgeId,color:{color:'yellow'}});
                    }
                    if(edges.get(reverseId)){
                        edges.update({id:reverseId,color:{color:'yellow'}});
                    }
                    network.body.data.nodes.update([{ id: node, color: 'yellow' }]);
                    previousNode=node;
                    await delay(1000);  // 1 saniye bekler
                }
            }

            colorNodesSequentially();
        }

    /*
		const adjVertices2 = {
    		A: { B: 1, C: 4 },
    		B: { A: 1, C: 2, D: 5 },
    		C: { A: 4, B: 2, D: 1 },
    		D: { B: 5, C: 1 },
		};

		const graph = new Graph(adjVertices2);
		graph.Dijkstra("A", "D");
    */

    </script>
</body>
</html>
