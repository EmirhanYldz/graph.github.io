<!DOCTYPE html>
<html>
<head>
    <title>Graph Visualization with vis.js</title>
    <style type="text/css">
        #graph-container {
            width: 800px;
            height: 600px;
            border: 1px solid lightgray;
        }
    </style>
    <style>
        .container {
            display: grid;
            grid-template-columns: 2fr 5fr;
            gap: 20px;
        }

        .left {
            flex: 1;
            padding: 20px;
        }

        .right {
            flex: 1;
            padding: 20px;
        }

        .text-area-div{
            padding-top: 20px;
        }

        .fixed-textarea {
            resize: none;
            width: 300px;
            height: 100px;
        }

        .fixed-textarea2 {
            resize: none;
            width: 340px;
            height: 260px;
        }

        form {
            padding: 10px;
            border: 1px solid #dddddd;
            border-radius: 5px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis-network.min.js"></script>
	<script src="script.js"></script>
</head>
<body>
<div class = "container">
    <div class = "left">
        <form id="graphForm">
            <p>Enter edges (format: node1-node2-weight, separate each edge with a comma):</p>
            <textarea class ="fixed-textarea" name="edges" id="edges" rows="5" cols="30" required></textarea><br>
            <input type="submit" value="Create Graph">
        </form>
        <div class="text-area-div">
            <textarea id="textArea" class ="fixed-textarea2" readonly>Deneme</textarea>
        </div>
    </div>
    <div id="graph-container" class = "right"></div>
</div>
    <button id="reset-button">RESET</button>
	<button id="dfs-button">Run DFS</button>
	<button id="bfs-button">Run BFS</button>
    <button id="euler-button">Run EULER</button>
	<button id="dijkstra-button">Run DIJKSTRA</button>
    <button id="tsp-button">Run TSP</button>
    <button id="kruskal-button">Run KRUSKAL</button>
    <button id="prim-button">Run PRIM</button>
    <button id="boruvka-button">Run BORUVKA</button>
    <button id="reverse-button">Run REVERSE</button>
    <button id="welsh-button">Run COLORING</button>

    <script type="text/javascript">
        let adjVertices = {};
        let edgeList = [];
        let resetAdjVertices;
        let resetEdgeList;

        document.getElementById("graphForm").addEventListener("submit", function(event) {
            event.preventDefault();
            adjVertices = {};
            edgeList = [];
            const edgesText = document.getElementById("edges").value;
            const edgesArray = edgesText.split(",").map(edge => edge.trim());
            edgesArray.forEach(edge => {
                const [src, dest, weight] = edge.split("-");
                addEdgeAdj(src,dest,weight);
                edgeList.push({ source: src, next: dest, weight: weight })
            });
            resetAdjVertices = JSON.parse(JSON.stringify(adjVertices));
            resetEdgeList = JSON.parse(JSON.stringify(edgeList));

            timers.forEach(timeoutId => clearTimeout(timeoutId));
            edges.clear();
            nodes.clear();
            document.getElementById("textArea").value = '';
            populateGraph(adjVertices);
        });

        //const adjVertices = {'1': {'31': 1.19, '80': 0.88, '46': 1.72, '38': 1.74, '51': 1.16, '33': 0.72}, '2': {'63': 0.8, '21': 1.96, '44': 0.59, '46': 1.35, '27': 1.14}, '3': {'32': 0.99, '42': 2.12, '26': 1.03, '43': 0.88, '64': 1.15, '20': 1.76, '15': 1.38}, '4': {'65': 1.28, '76': 0.97, '36': 0.9, '25': 1.79, '49': 1.51, '13': 1.62}, '5': {'66': 1.32, '60': 0.79, '55': 0.81, '19': 0.89}, '6': {'42': 2.09, '68': 1.95, '40': 1.53, '39': 5.92, '18': 1.02, '14': 1.43, '26': 2.34, '3': 2.58}, '7': {'33': 3.93, '70': 2.54, '42': 2.03, '32': 0.89, '15': 0.86, '48': 2.37}, '8': {'53': 1.31, '25': 1.4, '75': 0.89}, '9': {'48': 0.83, '20': 1.25, '45': 0.87, '35': 0.91}, '10': {'35': 1.44, '45': 1.12, '43': 2.11, '16': 1.33, '17': 1.55}, '11': {'43': 0.65, '26': 0.53, '14': 1.6, '54': 0.74, '16': 1.02}, '12': {'21': 1.27, '49': 0.99, '25': 0.98, '24': 1.44, '62': 1.35, '23': 1.59}, '13': {'56': 0.49, '65': 1.29, '4': 1.62, '49': 0.66, '72': 1.11}, '14': {'26': 1.33, '6': 1.43, '18': 2.03, '67': 0.91, '81': 0.5, '54': 1.15, '11': 1.6}, '15': {'48': 1.72, '7': 0.86, '32': 0.58, '3': 1.38, '20': 1.03}, '16': {'10': 1.33, '43': 1.25, '11': 1.02, '54': 1.44, '41': 1.01, '77': 0.43}, '17': {'10': 1.55, '59': 1.38, '22': 1.53}, '18': {'6': 1.02, '71': 0.76, '19': 1.34, '37': 0.81, '67': 2.01, '14': 2.03, '78': 1.16}, '19': {'66': 0.75, '5': 0.89, '55': 1.56, '57': 1.49, '37': 1.44, '18': 1.34, '71': 1.6}, '20': {'48': 0.92, '15': 1.03, '3': 1.76, '64': 0.96, '45': 1.86, '9': 1.25}, '21': {'63': 1.62, '47': 0.77, '72': 0.91, '49': 1.84, '12': 1.27, '23': 1.26, '44': 1.97, '2': 1.96}, '22': {'17': 1.53, '59': 1.18, '71': 7.19}, '23': {'21': 1.26, '12': 1.59, '62': 0.66, '24': 1.1, '44': 0.97}, '24': {'23': 1.1, '62': 0.45, '12': 1.44, '25': 1.78, '69': 0.88, '29': 0.69, '28': 1.61, '58': 2.48, '44': 1.83}, '25': {'12': 0.98, '49': 1.07, '4': 1.79, '36': 1.97, '75': 1.88, '8': 1.4, '53': 1.35, '69': 1.1, '24': 1.78}, '26': {'3': 1.03, '42': 2.74, '6': 2.34, '14': 1.33, '11': 0.53, '43': 0.65}, '27': {'79': 0.44, '63': 1.42, '2': 1.14, '46': 0.68, '80': 1.22, '31': 1.23}, '28': {'29': 1.22, '61': 1.33, '24': 1.61, '58': 1.8, '52': 0.52}, '29': {'24': 0.69, '69': 0.74, '61': 0.6, '28': 1.22}, '30': {'65': 0.96, '73': 1.25}, '31': {'79': 0.83, '27': 1.23, '80': 0.83, '1': 1.19}, '32': {'7': 0.89, '42': 1.93, '3': 0.99, '15': 0.58}, '33': {'1': 0.72, '51': 1.17, '42': 2.4, '70': 1.45, '7': 3.93}, '34': {'41': 0.92, '59': 1.46, '39': 1.9}, '35': {'9': 0.91, '45': 0.36, '10': 1.44}, '36': {'4': 0.9, '76': 1.16, '75': 0.63, '25': 1.97}, '37': {'19': 1.44, '57': 1.51, '18': 0.81, '74': 1.34, '78': 1.18}, '38': {'1': 1.74, '46': 1.85, '58': 1.84, '66': 1.27, '50': 0.79, '51': 1.1}, '39': {'22': 0.66, '59': 0.81, '34': 1.9}, '40': {'50': 0.68, '66': 0.93, '71': 0.96, '6': 1.53, '68': 0.79}, '41': {'77': 0.65, '34': 0.92, '16': 1.01, '11': 0.82, '54': 0.58}, '42': {'3': 2.12, '6': 2.09, '7': 2.03, '26': 2.74, '32': 1.93, '70': 1.02, '33': 2.4, '51': 2.2, '68': 1.63}, '43': {'26': 0.65, '11': 0.65, '45': 2.68, '64': 0.93, '3': 0.88, '16': 1.25, '10': 2.11}, '44': {'23': 0.97, '58': 1.9, '24': 1.83, '46': 1.57, '21': 1.97}, '45': {'10': 1.12, '43': 2.68, '64': 1.98, '20': 1.86, '9': 0.87, '35': 0.36}, '46': {'2': 1.35, '27': 0.68, '79': 0.89, '1': 1.72, '80': 0.85, '38': 1.85, '58': 2.16, '44': 1.57}, '47': {'73': 1.77, '56': 1.37, '72': 0.69, '21': 0.77, '63': 1.93}, '48': {'7': 2.37, '15': 1.72, '20': 0.92, '9': 0.83}, '49': {'25': 1.07, '4': 1.51, '13': 0.66, '72': 1.23, '21': 1.84, '12': 0.99}, '50': {'38': 0.79, '66': 1.13, '40': 0.68, '68': 0.73, '51': 0.73}, '51': {'50': 0.73, '68': 0.76, '42': 2.2, '33': 1.17, '1': 1.16, '38': 1.1}, '52': {'28': 0.52, '55': 1.58, '60': 1.48, '58': 1.51}, '53': {'25': 1.35, '8': 1.31, '61': 0.81, '69': 0.82}, '54': {'41': 0.58, '81': 0.74, '14': 1.15, '11': 0.74, '16': 1.44}, '55': {'57': 1.39, '19': 1.56, '5': 0.81, '60': 1.0, '52': 1.58}, '56': {'65': 1.56, '73': 0.75, '47': 1.37, '72': 0.82, '13': 0.49}, '57': {'55': 1.39, '19': 1.49, '37': 1.51}, '58': {'52': 1.51, '28': 1.8, '24': 2.48, '44': 1.9, '46': 2.16, '38': 1.84, '66': 2.2, '60': 0.74}, '59': {'22': 1.18, '39': 0.81, '34': 1.46, '17': 1.38}, '60': {'52': 1.48, '55': 1.0, '5': 0.79, '66': 1.81, '58': 0.74}, '61': {'53': 0.81, '69': 0.9, '29': 0.6, '28': 1.33}, '62': {'24': 0.45, '12': 1.35, '23': 0.66}, '63': {'47': 1.93, '21': 1.62, '2': 0.8, '27': 1.42}, '64': {'43': 0.93, '3': 1.15, '20': 0.96, '45': 1.98}, '65': {'30': 0.96, '73': 1.41, '56': 1.56, '13': 1.29, '4': 1.28}, '66': {'60': 1.81, '58': 2.2, '38': 1.27, '50': 1.13, '40': 0.93, '71': 1.3, '19': 0.75, '5': 1.32}, '67': {'78': 0.86, '74': 0.67, '14': 0.91, '81': 0.89}, '68': {'6': 1.95, '42': 1.63, '40': 0.79, '50': 0.73, '51': 0.76}, '69': {'25': 1.1, '53': 0.82, '61': 0.9, '29': 0.74, '24': 0.88}, '70': {'42': 1.02, '33': 1.45, '7': 2.54}, '71': {'19': 1.6, '66': 1.3, '40': 0.96, '6': 0.67, '18': 0.76}, '72': {'56': 0.82, '13': 1.11, '49': 1.23, '21': 0.91, '47': 0.69}, '73': {'56': 0.75, '65': 1.41, '30': 1.25, '47': 1.77}, '74': {'78': 0.41, '37': 1.34, '67': 0.67}, '75': {'25': 1.88, '36': 0.63, '8': 0.89}, '76': {'4': 0.97, '36': 1.16}, '77': {'41': 0.65, '16': 0.43}, '78': {'74': 0.41, '37': 1.18, '18': 1.16, '67': 0.86}, '79': {'27': 0.44, '31': 0.83}, '80': {'27': 1.22, '46': 0.85, '1': 0.88, '31': 0.83}, '81': {'67': 0.89, '14': 0.5, '54': 0.74}};

        /*
        let adjVertices = {
    		A: { B:5 , C:7 },
    		B: { A:5 , C:9 },
    		C: { A:7 , B:9 , D:6 },
    		D: { C:6 , E:2 , F:1 , G:5 },
            E: { D:2 , F:3 },
            F: { D:1 , E:3 , G:2 },
            G: { D:5 , F:2 }
		};

        */


        const nodes = new vis.DataSet();
        const edges = new vis.DataSet();

        const container = document.getElementById('graph-container');
        container.style.width = '800px';
        container.style.height = '500px';

        const data = {
            nodes: nodes,
            edges: edges
        };

        const options = {
            nodes: {

            },
            edges: {
                color: {
                    inherit: false
                }
            },
        };

        const network = new vis.Network(container, data, options);

        function removeEdgeAdj(u, v) {
            delete adjVertices[u][v];
            delete adjVertices[v][u];
        }

        function addEdgeAdj(src, dest, weight) {
            if (!adjVertices.hasOwnProperty(src)) {
                adjVertices[src]={};
            }
            if (!adjVertices.hasOwnProperty(dest)) {
                adjVertices[dest]={};
            }
            adjVertices[src][dest] = weight;
            adjVertices[dest][src] = weight;
        }

        function populateGraph(adjVertices) {
            //while(edgeList.length){edgeList.pop()}
			const addedEdges = new Set(); // To track added edges

    		for (const node in adjVertices) {
        		nodes.add({ id: node, label: node});

        		for (const neighbor in adjVertices[node]) {
					const edgeId = `${node}-${neighbor}`;
					const reverseEdgeId = `${neighbor}-${node}`;
            		const weight = adjVertices[node][neighbor];

            		// Check if the edge is already added
           			if (!addedEdges.has(edgeId) && !addedEdges.has(reverseEdgeId)) {
                		edges.add({ id: edgeId, from: node, to: neighbor, label: String(weight)});
                        //edgeList.push({ source: node, next: neighbor, weight: weight })
						addedEdges.add(edgeId)
            		}
        		}
    		}
		}
		
		const dfsButton = document.getElementById('dfs-button');
        dfsButton.addEventListener('click', () => {
            const startNode = prompt('Enter the starting node for DFS:');
            if (startNode) {
                runDFS(startNode);
            }
        });
		const bfsButton = document.getElementById('bfs-button');
        bfsButton.addEventListener('click', () => {
            const startNode = prompt('Enter the starting node for BFS:');
            if (startNode) {
                runBFS(startNode);
            }
        });
		const dijkstraButton = document.getElementById('dijkstra-button');
        dijkstraButton.addEventListener('click', () => {
            const startNode = prompt('Enter the starting node for dijkstra:');
            const endNode = prompt('Enter the ending node for dijkstra:')
            if (startNode && endNode) {
                runDijkstra(startNode,endNode);
            }
        });
        const resetButton = document.getElementById('reset-button');
        resetButton.addEventListener('click', () => {
            timers.forEach(timeoutId => clearTimeout(timeoutId));
            edges.clear();
            nodes.clear();
            adjVertices = JSON.parse(JSON.stringify(resetAdjVertices));
            edgeList = JSON.parse(JSON.stringify(resetEdgeList));
            document.getElementById("textArea").value = '';
            populateGraph(adjVertices);
        });
        const eulerButton = document.getElementById('euler-button');
        eulerButton.addEventListener('click', () => {
            runEuler();
        });
        const tspButton = document.getElementById('tsp-button');
        tspButton.addEventListener('click', () => {
            const startNode = prompt('Enter the starting node for TSP:');
            if (startNode) {
                runTSP(startNode);
            }
        });
        const kruskalButton = document.getElementById('kruskal-button');
        kruskalButton.addEventListener('click', () => {
            runKruskal();
        });
        const primButton = document.getElementById('prim-button');
        primButton.addEventListener('click', () => {
            runPrim();
        });
        const boruvkaButton = document.getElementById('boruvka-button');
        boruvkaButton.addEventListener('click', () => {
            runBoruvkaSollin();
        });
        const reverseButton = document.getElementById('reverse-button');
        reverseButton.addEventListener('click', () => {
            runReverseDelete();
        });
        const welshButton = document.getElementById('welsh-button');
        welshButton.addEventListener('click', () => {
            runWelshPowell();
        });
        const textArea = document.getElementById('textArea');

        const timers = [];
        async function colorNodes(nodeList){
            const delay = ms => new Promise(resolve => {
                const timeoutId = setTimeout(resolve, ms);
                timers.push(timeoutId);
            });

            for(const node of nodeList) {
                textArea.value = textArea.value + node +'  added .. \n'
                network.body.data.nodes.update([{id: node, color: 'yellow'}]);
                await delay(1000);
            }
            var result = nodeList.join('->');

            textArea.value = textArea.value + result ;
        }
        function runDFS(startNode){
            const result = [];

            function DFSUtil(node, result) {
                if (!result.includes(node)) {
                    result.push(node);
                    const neighbors = Object.keys(adjVertices[node]);
                    for (const n of neighbors) {
                        DFSUtil(n, result);
                    }
                }
            }

            DFSUtil(startNode, result);
            colorNodes(result)
        }

		function runBFS(startNode) {
            const result = [];
			const queue = [];

            queue.push(startNode);

            while (queue.length > 0) {
                const current = queue.shift();

                if (!result.includes(current)) {
                    result.push(current);
                    queue.push(...Object.keys(adjVertices[current]));
                }
            }
            colorNodes(result);
		}

        function runDijkstra(start,finish){
            const visitedNodes = new Set();
            const distance = new Map();
            const previousNode = new Map();

            function getNodeWithShortestDistance() {
                let result = null;
                let shortestDistance = Infinity;
                for (const node of distance.keys()) {
                    if (!visitedNodes.has(node) && distance.get(node) < shortestDistance) {
                        result = node;
                        shortestDistance = distance.get(node);
                    }
                }
                return result;
            }

            function getShortestPath(endNode) {
                const path = [];
                let currentNode = endNode;
                while (currentNode !== null) {
                    path.unshift(currentNode);
                    currentNode = previousNode.get(currentNode);
                }
                return path;
            }

            for (const node of Object.keys(adjVertices)) {
                if (node === start) {
                    distance.set(node, 0);
                } else {
                    distance.set(node, Infinity);
                }
                previousNode.set(node, null);
            }

            while (!visitedNodes.has(finish)) {
                const currentNode = getNodeWithShortestDistance();
                visitedNodes.add(currentNode);

                const neighbors = adjVertices[currentNode];
                for (const neighbor in neighbors) {
                    const cost = neighbors[neighbor];
                    const totalCost = cost + distance.get(currentNode);
                    if (totalCost < distance.get(neighbor)) {
                        distance.set(neighbor, totalCost);
                        previousNode.set(neighbor, currentNode);
                    }
                }
            }


            async function colorNodesSequentially() {
                const path = getShortestPath(finish);
                const delay = ms => new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    timers.push(timeoutId);
                });
                var result =path.join(' -> ');
                let previousNode = path.shift();
                textArea.value = textArea.value + previousNode + ' node added .. \n';
                network.body.data.nodes.update([{ id: previousNode, color: 'yellow' }]);
                await delay(1000);

                for (const node of path) {
                    const edgeId =`${node}-${previousNode}`
                    const reverseId =`${previousNode}-${node}`
                    textArea.value = textArea.value + edgeId + ' edge added .. \n';
                    if(edges.get(edgeId)){
                        edges.update({id:edgeId,color:{color:'yellow'}});
                    }
                    if(edges.get(reverseId)){
                        edges.update({id:reverseId,color:{color:'yellow'}});
                    }
                    textArea.value = textArea.value + node + ' node added .. \n';
                    network.body.data.nodes.update([{ id: node, color: 'yellow' }]);
                    previousNode=node;
                    await delay(1000);  // 1 saniye bekler
                }
                textArea.value = textArea.value + result;
            }
            colorNodesSequentially();
        }

        function runEuler(){

            function addEdge(src, dest, weight) {
                if (!adjVertices.hasOwnProperty(src)) {
                    addVertex(src);
                }
                if (!adjVertices.hasOwnProperty(dest)) {
                    addVertex(dest);
                }
                adjVertices[src][dest] = weight;
                adjVertices[dest][src] = weight;
            }

            function removeEdge(u, v) {
                delete adjVertices[u][v];
                delete adjVertices[v][u];
            }

            function addVertex(vertex) {
                adjVertices[vertex] = {};
            }

            function isValidNextEdge(u, v) {
                if (Object.keys(adjVertices[u]).length === 1) {
                    return true;
                }

                const count1 = DFS(u).length;

                removeEdge(u, v);

                const count2 = DFS(u).length;

                addEdge(u, v);

                return count1 <= count2;
            }

            function DFS(node) {
                const result = [];
                DFSUtil(node, result);
                return result;
            }

            function DFSUtil(node, result) {
                if (!result.includes(node)) {
                    result.push(node);
                    for (const n of Object.keys(adjVertices[node])) {
                        DFSUtil(n, result);
                    }
                }
            }

            async function colorEulerUtil(u) {
                const delay = ms => new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    timers.push(timeoutId);
                });
                path.push(u);
                textArea.value = textArea.value + u + ' node added .. \n';
                network.body.data.nodes.update([{ id: u, color: 'yellow' }]);
                await delay(1000);

                for (const v of Object.keys(adjVertices[u])) {
                    if (isValidNextEdge(u, v)) {
                        const edgeId =`${u}-${v}`
                        const reverseId =`${v}-${u}`
                        textArea.value = textArea.value + edgeId + ' edge added .. \n';
                        if(edges.get(edgeId)){
                            edges.update({id:edgeId,color:{color:'yellow'}});
                        }
                        if(edges.get(reverseId)){
                            edges.update({id:reverseId,color:{color:'yellow'}});
                        }
                        network.body.data.nodes.update([{ id: v, color: 'yellow' }]);
                        removeEdge(u, v);
                        await colorEulerUtil(v);
                        break;
                    }
                }
            }

            async function runningEuler(u){
                await colorEulerUtil(u);
                var result = path.join(' -> ');
                textArea.value= textArea.value + result;
            }

            const path = [];
            let u = null;
            const keys = Object.keys(adjVertices);
            u = keys.shift();

            for (const key of keys) {
                if (Object.keys(adjVertices[key]).length % 2 !== 0) {
                    u = key;
                    break;
                }
            }

            runningEuler(u);

        }

        function runTSP(startNode){
            let cost = 0;
            const path = [];
            const visited = new Map();

            for (const city of Object.keys(adjVertices)) {
                visited.set(city, false);
            }

            let currentCity = startNode;
            path.push(currentCity);
            visited.set(currentCity, true);

            while (path.length < Object.keys(adjVertices).length) {
                let minDistance = Number.MAX_SAFE_INTEGER;
                let nextCity = null;

                for (const [neighborCity, distance] of Object.entries(adjVertices[currentCity])) {
                    if (!visited.get(neighborCity)) {
                        if (distance < minDistance) {
                            minDistance = distance;
                            nextCity = neighborCity;
                        }
                    }
                }

                path.push(nextCity);
                cost += minDistance;
                visited.set(nextCity, true);
                currentCity = nextCity;
            }

            async function colorNodesSequentially() {
                const delay = ms => new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    timers.push(timeoutId);
                });

                let previousNode = path.shift();
                network.body.data.nodes.update([{ id: previousNode, color: 'yellow' }]);
                await delay(1000);

                for (const node of path) {
                    const edgeId =`${node}-${previousNode}`
                    const reverseId =`${previousNode}-${node}`
                    if(edges.get(edgeId)){
                        edges.update({id:edgeId,color:{color:'yellow'}});
                    }
                    if(edges.get(reverseId)){
                        edges.update({id:reverseId,color:{color:'yellow'}});
                    }
                    console.log(node);
                    network.body.data.nodes.update([{ id: node, color: 'yellow' }]);
                    previousNode=node;
                    await delay(1000);  // 1 saniye bekler
                }
            }

            colorNodesSequentially();
        }

        function runKruskal(){

            let MST = {};
            let cost = 0;
            edgeList.sort((p1,p2) => p1.weight - p2.weight);

            function removeEdge(u, v, graph) {
                delete graph[u][v];
                delete graph[v][u];
            }

            function addEdgeMST(src, dest, weight) {
                if (!MST.hasOwnProperty(src)) {
                    MST[src]={};
                }
                if (!MST.hasOwnProperty(dest)) {
                    MST[dest]={};
                }
                MST[src][dest] = weight;
                MST[dest][src] = weight;
            }

            function isCyclic(graph) {
                const visited = new Set();

                for (const key of Object.keys(graph)) {
                    if (!visited.has(key)) {
                        if (isCyclicUtil(key, visited, null, graph)) {
                            return true;
                        }
                    }
                }

                return false;
            }

            function isCyclicUtil(current, visited, parent, graph)
            {
                visited.add(current);

                for (const key of Object.keys(graph[current])) {
                    if (!visited.has(key)) {
                        if (isCyclicUtil(key, visited, current, graph)) {
                            return true;
                        }
                    } else if (key !== parent) {
                        return true;
                    }
                }

                return false;
            }

            async function colorMST(){
                const delay = ms => new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    timers.push(timeoutId);
                });

                for (const edge of edgeList) {
                    const source = edge.source;
                    const next = edge.next;
                    const weight = edge.weight;

                    addEdgeMST(source, next, weight);
                    const edgeId =`${source}-${next}`
                    const reverseId =`${next}-${source}`
                    textArea.value+=edgeId+' edge added..\n';
                    if(edges.get(edgeId)){
                        edges.update({id:edgeId,color:{color:'yellow'}});
                    }
                    if(edges.get(reverseId)){
                        edges.update({id:reverseId,color:{color:'yellow'}});
                    }
                    await delay(1000);

                    cost += weight;
                    if (isCyclic(MST)) {
                        removeEdge(source, next, MST);
                        textArea.value+=edgeId+' edge removed..\n';
                        if(edges.get(edgeId)){
                            edges.update({id:edgeId,color:{}});
                        }
                        if(edges.get(reverseId)){
                            edges.update({id:reverseId,color:{}});
                        }
                        await delay(1000);
                        cost -= weight;
                    }
                }
                for(const node of Object.keys(MST)) {
                    network.body.data.nodes.update([{id:node ,color: 'yellow'}]);
                }
                textArea.value +='all nodes colored\n';
                textArea.value +='new MST : '+ JSON.stringify(MST, null, 2);
            }
            /*
            for (const edge of edgeList) {
                const source = edge.source;
                const next = edge.next;
                const weight = edge.weight;

                addEdgeMST(source, next, weight);
                cost += weight;
                if (isCyclic(MST)) {
                    removeEdge(source, next, MST);
                    cost -= weight;
                }
            }
            */

            colorMST();
        }

        function runPrim(){
            let MST = {};
            const nodes = [...Object.keys(adjVertices)];
            const node = nodes[0]; // İlk düğümü seçin veya istediğiniz düğümü seçin

            function primUtil(graph, copy) {
                let cost = Number.MAX_VALUE;
                let currentNode = null;
                let edgeNode = null;

                for (const vertex of Object.keys(graph)) {
                    const cEdgeInfo = getCloseEdge(vertex, cost, copy, graph);
                    if (!cEdgeInfo) {
                        continue;
                    }
                    const [cNode, eNode, cCost] = cEdgeInfo;
                    if (cCost < cost) {
                        currentNode = cNode;
                        edgeNode = eNode;
                        cost = cCost;
                    }
                }

                addEdgeToGraph(currentNode, edgeNode, cost, graph);
                const edgeId =`${currentNode}-${edgeNode}`
                const reverseId =`${edgeNode}-${currentNode}`
                textArea.value += edgeId + ' edge added..\n';
                if(edges.get(edgeId)){
                    edges.update({id:edgeId,color:{color:'yellow'}});
                }
                if(edges.get(reverseId)){
                    edges.update({id:reverseId,color:{color:'yellow'}});
                }
            }

            function getCloseEdge(node, cost, copy, graph) {
                let closeEdge = null;

                for (const neighbor in copy[node]) {
                    if (graph[node].hasOwnProperty(neighbor)) {
                        continue;
                    }
                    if (copy[node][neighbor] < cost) {
                        closeEdge = [node, neighbor, copy[node][neighbor]];
                        cost = copy[node][neighbor];
                    }
                }

                return closeEdge;
            }

            function addEdgeToGraph(src, dest, weight, graph) {
                if (!graph.hasOwnProperty(src)) {
                    graph[src]={};
                }
                if (!graph.hasOwnProperty(dest)) {
                    graph[dest]={};
                }
                graph[src][dest]=weight;
                graph[dest][src]=weight;
            }

            function addVertexToGraph(graph, vertex) {
                if (!graph.hasOwnProperty(vertex)) {
                    graph[vertex]={}
                }
            }

            addVertexToGraph(MST, node);

            async function colorPrim() {
                const delay = ms => new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    timers.push(timeoutId);
                });

                for (let i = 0; i < nodes.length - 1; i++) {
                    primUtil(MST, adjVertices);
                    await delay(1000);
                }
                for(const node of Object.keys(MST)){
                    network.body.data.nodes.update([{id:node ,color: 'yellow'}]);
                }
                textArea.value +='all nodes colored\n';
                textArea.value +='new MST : ' + JSON.stringify(MST,null,2);
            }

            colorPrim();

        }

        function runBoruvkaSollin(){
            let MST = {}
            let copyAdjVertices = {}
            let unionFind = new UnionFind();

            function addEdgeToGraph(src, dest, weight, graph) {
                if (!graph.hasOwnProperty(src)) {
                    graph[src]={};
                }
                if (!graph.hasOwnProperty(dest)) {
                    graph[dest]={};
                }

                graph[src][dest] = weight;
                graph[dest][src] = weight;
            }

            function removeEdge(src, dest, graph) {
                if (graph[src] && graph[src][dest]) {
                    delete graph[src][dest];
                }
                if (graph[dest] && graph[dest][src]) {
                    delete graph[dest][src];
                }
            }

            function lessWeightEdge(groups, graph, copy, unionFind) {
                let current = null;
                let next = null;
                let cost = Number.MAX_VALUE;

                groups.forEach(node => {
                    for (const neighbor of Object.keys(copy[node])) {
                        if (!groups.includes(neighbor) && copy[node][neighbor] < cost) {
                            current = node;
                            next = neighbor;
                            cost = copy[node][neighbor];
                        }
                    }
                });

                if (current === null || next === null || cost === Number.MAX_VALUE) {
                    return;
                }

                addEdgeToGraph(current, next, cost, graph);
                const edgeId =`${current}-${next}`
                const reverseId =`${next}-${current}`
                textArea.value += edgeId + ' edge added..\n';
                if(edges.get(edgeId)){
                    edges.update({id:edgeId,color:{color:'yellow'}});
                }
                if(edges.get(reverseId)){
                    edges.update({id:reverseId,color:{color:'yellow'}});
                }
                unionFind.union(current, next);
            }

            for (const vertex of Object.keys(adjVertices)) {
                unionFind.makeSet(vertex);
                for (const neighbor of Object.keys(adjVertices[vertex])) {
                    addEdgeToGraph(vertex, neighbor, adjVertices[vertex][neighbor], copyAdjVertices);
                }
            }
            async function colorBoruvka() {
                const delay = ms => new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    timers.push(timeoutId);
                });

                for (const vertex of Object.keys(adjVertices)) {
                    let current = vertex;
                    let next = null;
                    let cost = Number.MAX_VALUE;

                    for (const neighbor of Object.keys(adjVertices[current])) {
                        if (adjVertices[current][neighbor] < cost) {
                            next = neighbor;
                            cost = adjVertices[current][next];
                        }
                    }

                    const edgeId =`${current}-${next}`
                    const reverseId =`${next}-${current}`

                    addEdgeToGraph(current, next, cost, MST);
                    if(edges.get(edgeId)){
                        if(!edges.get(edgeId).hasOwnProperty('color')){
                            textArea.value += edgeId + ' edge added..\n';
                        }
                        edges.update({id:edgeId,color: {color:'yellow'}} );
                        await delay(1000);
                    }
                    if(edges.get(reverseId)){
                        if(!edges.get(reverseId).hasOwnProperty('color')){
                            textArea.value += reverseId + ' edge added..\n';
                        }
                        edges.update({id:reverseId,color:{color:'yellow'}});
                        await delay(1000);
                    }
                    removeEdge(current, next, copyAdjVertices);
                }

                for (const vertex of Object.keys(MST)) {
                    for (const neighbor of Object.keys(MST[vertex])) {
                        unionFind.union(vertex, neighbor);
                    }
                }

                let connectedNodes = unionFind.listConnectedNodes();

                while (connectedNodes.length !== 1) {
                    let nodeList = connectedNodes[0];
                    let previousGraph = MST;
                    lessWeightEdge(nodeList, MST, copyAdjVertices, unionFind);
                    if(previousGraph!==MST){
                        await delay(1000);
                    }
                    connectedNodes = unionFind.listConnectedNodes();
                }

                for(const node of Object.keys(MST)){
                    network.body.data.nodes.update([{id:node ,color: 'yellow'}]);
                }
                textArea.value += 'all nodes colored..\n';
                textArea.value += 'new MST: ' + JSON.stringify(MST,null,2);
            }

            colorBoruvka();
        }

        function runReverseDelete(){
            let MST = adjVertices;
            edgeList.sort((p1,p2) => p2.weight - p1.weight);

            function removeEdge(u, v, graph) {
                delete graph[u][v];
                delete graph[v][u];
            }

            function addEdgeMST(src, dest, weight) {
                if (!MST.hasOwnProperty(src)) {
                    MST[src]={};
                }
                if (!MST.hasOwnProperty(dest)) {
                    MST[dest]={};
                }
                MST[src][dest] = weight;
                MST[dest][src] = weight;
            }

            function isConnected(node, graph) {
                return DFS(node, graph).length === Object.keys(graph).length;
            }

            function DFS(node, graph) {
                let result = [];
                DFSUtil(node, result, graph);
                return result;
            }

            function DFSUtil(node, result, graph) {
                if (!result.includes(node)) {
                    result.push(node);
                    for (let n of Object.keys(graph[node])) {
                        DFSUtil(n, result, graph);
                    }
                }
            }

            async function colorMST(){
                const delay = ms => new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    timers.push(timeoutId);
                });
                edges.forEach(function (edge) {
                    edges.update({ id: edge.id, color: { color: 'yellow' } });
                });
                textArea.value += 'all edges added..\n';
                for(let edge of edgeList){
                    const edgeId =`${edge.source}-${edge.next}`
                    const reverseId =`${edge.next}-${edge.source}`
                    removeEdge(edge.source,edge.next,MST);
                    textArea.value += edgeId + ' edge removed..\n';
                    if(edges.get(edgeId)){
                        edges.update({id:edgeId,color:{}});
                    }
                    if(edges.get(reverseId)){
                        edges.update({id:reverseId,color:{}});
                    }
                    await delay(1000);
                    if(!isConnected(edge.source,MST)){
                        addEdgeMST(edge.source,edge.next,edge.weight);
                        textArea.value += edgeId + ' edge added again..\n';
                        if(edges.get(edgeId)){
                            edges.update({id:edgeId,color:{color:'yellow'}});
                        }
                        if(edges.get(reverseId)){
                            edges.update({id:reverseId,color:{color:'yellow'}});
                        }
                        await delay(1000);
                    }
                }
                for(const node of Object.keys(MST)) {
                    network.body.data.nodes.update([{id:node ,color: 'yellow'}]);
                }

                textArea.value += 'all nodes colored..\n';
                textArea.value += 'new MST: '+ JSON.stringify(MST,null,2);
            }

            colorMST();
        }

        function runWelshPowell(){
            let vertexColor = {};
            let vertexList = {};
            const colors = ['RED', 'BLUE', 'GREEN', 'YELLOW', 'PURPLE', 'ORANGE','GRAY','BLACK','WHITE'];

            function nodeCheck(adjNodes, vertexColor, control) {
                for (let string of adjNodes) {
                    let color = vertexColor[string];
                    if (color !== null && color === control) {
                        return false;
                    }
                }
                return true;
            }

            for (let vertex of Object.keys(adjVertices)) {
                vertexList[vertex] = Object.keys(adjVertices[vertex]).length;
                vertexColor[vertex] = null;
            }
            let sortedList = Object.entries(vertexList).sort((a, b) => b[1] - a[1]);

            async function colorNodeDifferent() {
                const delay = ms => new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    timers.push(timeoutId);
                });

                let i = 0;
                while (Object.values(vertexColor).some(color => color === null)) {
                    for (let [node, _] of sortedList) {
                        if (vertexColor[node] === null && nodeCheck(Object.keys(adjVertices[node]), vertexColor, colors[i])) {
                            vertexColor[node] = colors[i];
                            textArea.value+= node + ' node colored to -> '+ colors[i]+ '\n';
                            network.body.data.nodes.update([{id:node ,color: colors[i]}]);
                            await delay(1000);
                        }
                    }
                    i++;
                }
                textArea.value += 'all nodes colored.. \n';
                textArea.value += 'number of color used -> '+ i;
            }
            colorNodeDifferent();
        }

    </script>
</body>
</html>
